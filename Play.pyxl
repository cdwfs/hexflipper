Play
════════════════════════════════════════════════════════════════════════

/** Clone of map for the game */
let map
let player_count
let all_player_hex_coords = [xy(1,9), xy(9,1), xy(5,1), xy(5,9)]
const PLAYER_NEUTRAL = -1
const INVALID_HEX = -2
const PLAYER_CLICK_SOUNDS = [
    {sound:blip_05_sound, pan: -50%, volume: 100%},
    {sound:blip_07_sound, pan: +50%, volume: 100%},
    {sound:blip_05_sound, pan: -50%, volume: 100%},
    {sound:blip_07_sound, pan: +50%, volume: 100%},
    ]
const PLAYER_TERRITORY_SPRITES = [
    hex_sprite.territory_p1,
    hex_sprite.territory_p2,
    hex_sprite.territory_p3,
    hex_sprite.territory_p4,
    ]
const PLAYER_OVERLAY_SPRITES = [
    hex_sprite.overlay_p1,
    hex_sprite.overlay_p2,
    hex_sprite.overlay_p3,
    hex_sprite.overlay_p4,
    ]
const PLAYER_PREVIEW_MAP_COORDS = [
    xy(3,8),
    xy(12,2),
    xy(3,2),
    xy(12,8),
    ]
const VALID_HEX_COORD_MASK = [
    0b0000000000000000,
    0b0000001111100000,
    0b0000001111110000,
    0b0000001111111000,
    0b0000001111111100,
    0b0000001111111110,
    0b0000000111111110,
    0b0000000011111110,
    0b0000000001111110,
    0b0000000000111110,
    0b0000000000000000,
    ]
const DIR_NE = 0
const DIR_E  = 1
const DIR_SE = 2
const DIR_SW = 3
const DIR_W  = 4
const DIR_NW = 5
const HEX_COORD_NEIGHBOR_OFFSETS = [
    xy(+0,+1), // NE
    xy(+1,+0), // E
    xy(+1,-1), // SE
    xy(+0,-1), // SW
    xy(-1,+0), // W
    xy(-1,+1), // NW
    ]
const ARROW_SPRITES = [
    hex_sprite.arrow_ne[0],
    hex_sprite.arrow_e[0],
    hex_sprite.arrow_se[0],
    hex_sprite.arrow_sw[0],
    hex_sprite.arrow_w[0],
    hex_sprite.arrow_nw[0],
    ]

let player_current_moves = [0,0,0,0]
let player_next_moves = [0,0,0,0]

// Draw a sprite at the provided map coordinates
def draw_sprite_on_hex_map(sprite, map_coord):
    let pos = xy(
        MUL(HEX_WIDTH, MAD(½, map_coord.y bitand 1, map_coord.x)),
        MUL(HEX_HEIGHT_75, map_coord.y))
    draw_sprite(sprite, pos)    

// Per-cell owner info
let map_cell_owner
// Get the player ID of a map cell (PLAYER_NEUTRAL for unclaimed cells, INVALID_HEX for cells outside the play area)
def get_cell_owner_map_coord(map_coord):
    return map_cell_owner[map_coord.x][map_coord.y]
def get_cell_owner_hex_coord(hex_coord):
    return get_cell_owner_map_coord(transform_hex_to_map_coord(hex_coord))
// Change the owner of a cell (including swapping its sprite)
def set_cell_owner_map_coord(map_coord, player_id):
    map_cell_owner[map_coord.x][map_coord.y] = player_id
    set_map_sprite(map, map_coord,
        if player_id == PLAYER_NEUTRAL then hex_sprite.territory_neutral else PLAYER_TERRITORY_SPRITES[player_id])
def set_cell_owner_hex_coord(hex_coord, player_id):
    set_cell_owner_map_coord(transform_hex_to_map_coord(hex_coord), player_id)
// Check whether a cell is within the play area
def is_valid_board_hex(hex_coord):
    return get_cell_owner_hex_coord(hex_coord) ≠ INVALID_HEX

// Generate a move code. Not all moves are equally likely.
def generate_move_code():
    const p = ξ
    let bit_count = 0
    if p < 0.50:
        bit_count = 1
    else if p < 0.80:
        bit_count = 2
    else if p < 0.90:
        bit_count = 3
    else if p < 0.95:
        bit_count = 4
    else if p < 0.98:
        bit_count = 5
    else:
        bit_count = 6
    let move = 0b000000
    const set_bits = slice(shuffled([0,1,2,3,4,5]), 0, bit_count)
    for b in set_bits:
        move ∪= 1<<b
    return move

// music playback
let bgmusic
let bgmusic2
let bgmusic_start_time = 0

enter(player_info)
────────────────────────────────────────────────────────────────────────

map = clone(game_board_map)
player_count = 2 // TODO: choose from 1-4 at title and pass via player_info

set_transform(xy(-48, SCREEN_SIZE.y + 8), xy(1, -1))

map_cell_owner = []
for x < size(map):
    let new_col = []
    for y < size(map[x]):
        let hc = transform_map_coord_to_hex(xy(x,y))
        new_col.push(if (VALID_HEX_COORD_MASK[hc.y] & (1<<hc.x)) ≠ 0 then PLAYER_NEUTRAL else INVALID_HEX)
    map_cell_owner.push(new_col)
// Players start on their own territory
for i < player_count:
    set_cell_owner_hex_coord(all_player_hex_coords[i], i)
    
// Start music loops playing
bgmusic = play_sound({sound:bgmusic_loop1_sound, loop:true})
bgmusic2 = play_sound({sound:bgmusic_loop2_sound, volume:0%, loop:true})
bgmusic_start_time = now()

// random starting moves for each player
for i < player_count:
    player_current_moves[i] = generate_move_code()
    player_next_moves[i] = generate_move_code()

leave
────────────────────────────────────────────────────────────────────────
set_transform(xy(0, SCREEN_SIZE.y), xy(1, -1))

frame
────────────────────────────────────────────────────────────────────────

//
// reactive-music stuff goes here
//

// yellow square in time with the beat
let beat = floor((now()-bgmusic_start_time) / 0.2)
let bim = beat % 12
if bim == 0 or bim == 2 or bim == 4 or bim == 7 or bim == 10:
    draw_corner_rect({corner:xy(100,100), size:xy(20,-20), color:#ff0, z:5})
// switch between two active loops
let measure = floor((now()-bgmusic_start_time) / 2.4)
if (measure % 2) == 0:
    set_volume(bgmusic, 100%)
    set_volume(bgmusic2, 0%)
else:
    set_volume(bgmusic, 0%)
    set_volume(bgmusic2, 100%)

for i < player_count:
    // handle dpad input
    const new_hex_coord = xy(all_player_hex_coords[i].x + gamepad_array[i].xx,
        all_player_hex_coords[i].y + gamepad_array[i].yy)
    if is_valid_board_hex(new_hex_coord):
        all_player_hex_coords[i] = new_hex_coord;
    // handle button A input
    const player_hex = all_player_hex_coords[i]
    if gamepad_array[i].aa:
        play_sound(PLAYER_CLICK_SOUNDS[i])
        map_set_sprite_by_hex(map, all_player_hex_coords[i], PLAYER_TERRITORY_SPRITES[i])
    // Update player "next move" previews
    let preview_mc = PLAYER_PREVIEW_MAP_COORDS[i]
    let preview_hc = transform_map_coord_to_hex(preview_mc)
    for neighbor < 6:
        map_set_sprite_by_hex(map, preview_hc + HEX_COORD_NEIGHBOR_OFFSETS[neighbor],
            if (player_next_moves[i] & (1<<neighbor)) ≠ 0 then ARROW_SPRITES[neighbor] else ∅)


// draw things
draw_hex_map(map)
for i < player_count:
    draw_sprite_on_hex_map(PLAYER_OVERLAY_SPRITES[i], transform_hex_to_map_coord(all_player_hex_coords[i]))
    for neighbor < 6:
        if (player_current_moves[i] & (1<<neighbor)) ≠ 0:
            draw_sprite_on_hex_map(ARROW_SPRITES[neighbor].animation.frame(mode_frames),
                transform_hex_to_map_coord(all_player_hex_coords[i] + HEX_COORD_NEIGHBOR_OFFSETS[neighbor]))    
